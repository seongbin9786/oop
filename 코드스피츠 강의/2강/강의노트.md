강의노트
=======

1. GOF의 디자인패턴 분류
    1. 생성패턴
        - 객체를 만들 때 이런식으로 만들면 좋아
    2. 구조패턴
        - 객체끼리 관계를 지을때, 어떤식으로 관계를 지으면 좋아
    3. 행동패턴
        - 알고리즘
        - 어떤 알고리즘적 문제를 객체간의 협력망으로 풀려면 이렇게 푸는게 좋아

2. 객체지향설계를 학습할 수 있는 분류
    1. 캡슐화
    2. 다형성
    3. 객체 관계
    4. 변화율
    5. **역할모델**

3. 알고리즘이 변화하는 이유 = 대부분 통제불가요소
    1. 비즈니스 변화
    2. 연관 라이브러리 변화
    3. 고객의 심경 변화

4. 기존 제어문 기반의 알고리즘이 갖는 문제
    - 수정하면 전체가 컴파일 됨
    - 알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다면?
    - 최대한 개별 알고리즘을 함수로 분리한다.
    - 왜 문제일까? 연관된 영역의 테스트를 모두 실시해야 하기 때문.
    - (ex) `if else if else ...` 중 한 분기를 고쳤다면 해당 `if else`를 모두 테스트해야 함.
    - 함수로 고치면 `if(1) case(1) else if(2) case(2)` 와 같이 수행할 수 있고, 각각만 테스트해도 됨.
    - `else if(3) case(3)` 등과 같이 경우가 추가되거나, 변경될 때
    - `if(1) { common() case(1) } else { common() case(2) }`와 같이 공통 로직의 변화
    - 공통 로직이 생기거나 변경되는 경우 기존의 제어문은 모두 테스트해야 함.
    - 답은 **격리**이다.

5. 적응형(Adoptive) 프로그램
    - 환경이 변하거나, 수정 요청이 왔을 때 유연하게 대응할 수 있는 어떤 철학
    - 객체지향

6. 알고리즘 분기 시 객체지향에서 선택할 수 있는 2가지 방법
    - 상속 위임
        1. case 마다 클래스를 생성해서 구현 코드를 작성한다.
        2. 부모 클래스에서 공통 코드를 포함하고, 재사용한다.
    - 소유 위임
        - 외부 계약 관계로 각각이 메시지로 분업하여 독립적인 문제를 해결한다.
        - 다른 객체를 자신이 소유하고, 해당 객체에 위임한다.
    - 실무에서는 두 전략을 복합적으로 사용한다.
    - GoF Design Pattern은 소유 위임을 많이 포함한다.
    - 소유 위임으로 가면, Type이 많이 나오게 된다. (분업 때문에)
    - 변화율이 높은 부분은 분할을 많이 하고, 없다면 아예 안 해도 됨

7. 전략 객체를 사용하면, 새로운 타입채로 바꾸는 것이 아닌, set 메소드로 전략 객체를 넘기는 것으로 행동을 변경할 수 있다. JS의 경우, 타입 선언이 아닌 함수로도 넘길 수 있기 때문에 비용이 덜 들어 타 언어에 비해 더 유리하다.
    - 단, 함수를 넘길 경우, 타입 체크를 사용할 수 없으므로 신뢰가 필요한 코드는 클래스로 작성한 후 타입 체크를 함이 올바른 코드이다.
    - 일반적으로 상속 위임보다, 전략 패턴을 사용하는 것이 낫다.
    - 전략 객체를 언제 사용할까? 일부만 변경되어야 할 때이다.
    - (Ex) 캐릭터에서 무기만 변경한다. 로더에서 파서만 변경한다. 등

8. 전략 객체를 사용할 때, `case`가 바뀔 때 마다 전략 객체를 생성하고, set 메소드를 호출하여 객체를 등록하는 것은 계산으로 문제를 해결하는 방법이다. 전략 객체를 변경할 때 마다 계속 이 행동을 반복해야 하는 것을 `switch-case`의 효과를 내면서, 연산이 없는 `route` 로직으로 변경할 수 있다. 라우팅은 Map, Hashtable 등으로 값으로 접근하는 방법을 사용하여, 연산을 용량으로 대체한다.

9. 실세계의 요구사항 조건을 없앨 순 없다. 단, 테이블을 통해서 `if-else if`문을 제거할 순 있다. 분기 수 만큼 객체를 만들고, 실행 시점에 경우의 수를 공급한다. 라우팅을 사용해서 얻는 이점은, 분기를 동적으로 정의할 수 있음에 있다. 이를 `실행 시점으로 분기를 옮긴다`라고 한다. 분기를 동적으로 정의한다는 것은 `일정한 통제 범위 내에서 확장 가능한 알고리즘 설계가 가능한 것`이다. 기능이 부분적으로 수정(업데이트)가 가능한가?는 이러한 설계를 통해서 만족 가능하다. 

10. 라우팅의 단점도 있다.
    1. 경우 처리 정의가 실행 시점에 내려왔기 때문에, 각각의 경우를 처리하는 코드가 분산되므로, 경우를 잘 처리하는 지 신경써야 한다. (팀 개발 시 주의해야 함) 
    2. 각 경우마다 단위 테스트가 필요하다.
    3. 실행 시점마다 알고리즘의 안정성을 담보해야 한다. (팀원의 수준이 일정 수준 이상이어야 함)

11. Factory, Builder 패턴을 사용하여 라우팅의 정의를 캡슐화할 수 있다.